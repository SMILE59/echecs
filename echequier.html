<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Échiquier Interactif - Meilleure Case</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 100%;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .piece-btn {
            padding: 10px 15px;
            font-size: 24px;
            border: 2px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }
        .piece-btn:hover {
            transform: scale(1.1);
            border-color: #667eea;
        }
        .piece-btn.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 3px solid #333;
            margin: 0 auto;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .square.light {
            background-color: #f0d9b5;
        }
        .square.dark {
            background-color: #b58863;
        }
        .square.controlled {
            background-color: rgba(255, 0, 0, 0.3) !important;
        }
        .square.best-placement {
            background-color: rgba(76, 175, 80, 0.7) !important;
            box-shadow: inset 0 0 0 3px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: inset 0 0 0 3px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: inset 0 0 0 3px #4CAF50, 0 0 15px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: inset 0 0 0 3px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5); }
        }
        .square:hover {
            opacity: 0.8;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .action-btn {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .action-btn:hover {
            background: #5568d3;
        }
        .info {
            text-align: center;
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }
        .score-display {
            text-align: center;
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        .best-move {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            font-weight: bold;
        }
        .best-move.hidden {
            display: none;
        }
		.square.best-placement {
            background-color: rgba(76, 175, 80, 0.7) !important;
            box-shadow: inset 0 0 0 3px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5);
            animation: pulse-best 2s infinite;
        }
        .square.worst-placement {
            background-color: rgba(244, 67, 54, 0.7) !important;
            box-shadow: inset 0 0 0 3px #f44336, 0 0 10px rgba(244, 67, 54, 0.5);
            animation: pulse-worst 2s infinite;
        }
        @keyframes pulse-best {
            0% { box-shadow: inset 0 0 0 3px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: inset 0 0 0 3px #4CAF50, 0 0 15px rgba(76, 175, 80, 0.8); }
            100% { box-shadow: inset 0 0 0 3px #4CAF50, 0 0 10px rgba(76, 175, 80, 0.5); }
        }
        @keyframes pulse-worst {
            0% { box-shadow: inset 0 0 0 3px #f44336, 0 0 10px rgba(244, 67, 54, 0.5); }
            50% { box-shadow: inset 0 0 0 3px #f44336, 0 0 15px rgba(244, 67, 54, 0.8); }
            100% { box-shadow: inset 0 0 0 3px #f44336, 0 0 10px rgba(244, 67, 54, 0.5); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>♔ Échiquier Interactif - Meilleure Case ♔</h1>
        
        <div class="score-display" id="scoreDisplay">
            Score: 0 pièces placées
        </div>
        
        <div class="best-move hidden" id="bestMove">
            <!-- Le contenu sera rempli par JavaScript -->
        </div>
        
        <div class="controls">
            <button class="piece-btn" data-piece="♔" data-type="king" data-color="white" title="Roi blanc">♔</button>
            <button class="piece-btn" data-piece="♕" data-type="queen" data-color="white" title="Dame blanche">♕</button>
            <button class="piece-btn" data-piece="♖" data-type="rook" data-color="white" title="Tour blanche">♖</button>
            <button class="piece-btn" data-piece="♗" data-type="bishop" data-color="white" title="Fou blanc">♗</button>
            <button class="piece-btn" data-piece="♘" data-type="knight" data-color="white" title="Cavalier blanc">♘</button>
            <button class="piece-btn" data-piece="♙" data-type="pawn" data-color="white" title="Pion blanc">♙</button>
        </div>
        
        <div class="board" id="board"></div>
        
        <div class="button-group">
            <button class="action-btn" onclick="toggleControlled()">Afficher/Masquer les cases contrôlées</button>
            <button class="action-btn" onclick="clearBoard()">Effacer l'échiquier</button>
        </div>
        
        <div class="info">
            <p>Cliquez sur une pièce puis sur l'échiquier pour la placer. Clic droit pour supprimer.</p>
            <p><strong>Objectif :</strong> Placez le maximum de pièces sans qu'elles s'attaquent mutuellement.</p>
            <p><strong>Indicateur :</strong> La meilleure case pour la pièce sélectionnée est mise en évidence en vert.</p>
        </div>
    </div>

    <script>
        let selectedPiece = null;
        let board = [];
        let showControlled = true;
        let score = 0;
        let bestPosition = null;

        // Initialisation du plateau
        for (let i = 0; i < 8; i++) {
            board[i] = [];
            for (let j = 0; j < 8; j++) {
                board[i][j] = null;
            }
        }

        function initBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    square.addEventListener('click', function() {
                        handleSquareClick(row, col);
                    });
                    square.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        removePiece(row, col);
                    });
                    
                    boardEl.appendChild(square);
                }
            }
            
            const pieceBtns = document.querySelectorAll('.piece-btn');
            pieceBtns.forEach(function(btn) {
                btn.addEventListener('click', function() {
                    selectPiece(btn);
                });
            });
            
            updateBoard();
            updateScore();
        }

        function selectPiece(btn) {
            const allBtns = document.querySelectorAll('.piece-btn');
            allBtns.forEach(function(b) {
                b.classList.remove('selected');
            });
            btn.classList.add('selected');
            
            selectedPiece = {
                symbol: btn.dataset.piece,
                type: btn.dataset.type,
                color: btn.dataset.color
            };
            
            // Calculer et afficher la meilleure position pour cette pièce
            updateBestPosition();
        }

        function handleSquareClick(row, col) {
            if (selectedPiece) {
                // Vérifier si le placement est valide (pas d'attaque mutuelle)
                if (isValidPlacement(row, col, selectedPiece)) {
                    board[row][col] = {
                        symbol: selectedPiece.symbol,
                        type: selectedPiece.type,
                        color: selectedPiece.color
                    };
                    updateBoard();
                    updateScore();
                    
                    // Recalculer la meilleure position après placement
                    updateBestPosition();
                } else {
                    alert("Placement invalide ! Cette case est attaquée par une autre pièce ou attaque une autre pièce.");
                }
            }
        }

        function removePiece(row, col) {
            board[row][col] = null;
            updateBoard();
            updateScore();
            
            // Recalculer la meilleure position après suppression
            if (selectedPiece) {
                updateBestPosition();
            }
        }

        function isValidPlacement(row, col, piece) {
            // Vérifier si la case est déjà occupée
            if (board[row][col]) return false;
            
            // Vérifier si la nouvelle pièce attaque une pièce existante
            const controlled = getControlledSquares(row, col, piece);
            for (let i = 0; i < controlled.length; i++) {
                const [r, c] = controlled[i];
                if (board[r][c]) {
                    return false;
                }
            }
            
            // Vérifier si une pièce existante attaque la nouvelle position
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c]) {
                        const existingControlled = getControlledSquares(r, c, board[r][c]);
                        for (let j = 0; j < existingControlled.length; j++) {
                            const [er, ec] = existingControlled[j];
                            if (er === row && ec === col) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        function getControlledSquares(row, col, piece) {
            const controlled = [];
            const type = piece.type;
            
            if (type === 'pawn') {
                // Les pions blancs attaquent en diagonale vers le haut
                if (col > 0 && row - 1 >= 0) {
                    controlled.push([row - 1, col - 1]);
                }
                if (col < 7 && row - 1 >= 0) {
                    controlled.push([row - 1, col + 1]);
                }
            } else if (type === 'knight') {
                const moves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                for (let i = 0; i < moves.length; i++) {
                    const dr = moves[i][0];
                    const dc = moves[i][1];
                    const nr = row + dr;
                    const nc = col + dc;
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        controlled.push([nr, nc]);
                    }
                }
            } else if (type === 'king') {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = row + dr;
                        const nc = col + dc;
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                            controlled.push([nr, nc]);
                        }
                    }
                }
            } else if (type === 'rook') {
                const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
                for (let d = 0; d < dirs.length; d++) {
                    const dr = dirs[d][0];
                    const dc = dirs[d][1];
                    for (let i = 1; i < 8; i++) {
                        const nr = row + dr * i;
                        const nc = col + dc * i;
                        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                        controlled.push([nr, nc]);
                        if (board[nr][nc]) break;
                    }
                }
            } else if (type === 'bishop') {
                const dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
                for (let d = 0; d < dirs.length; d++) {
                    const dr = dirs[d][0];
                    const dc = dirs[d][1];
                    for (let i = 1; i < 8; i++) {
                        const nr = row + dr * i;
                        const nc = col + dc * i;
                        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                        controlled.push([nr, nc]);
                        if (board[nr][nc]) break;
                    }
                }
            } else if (type === 'queen') {
                const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
                for (let d = 0; d < dirs.length; d++) {
                    const dr = dirs[d][0];
                    const dc = dirs[d][1];
                    for (let i = 1; i < 8; i++) {
                        const nr = row + dr * i;
                        const nc = col + dc * i;
                        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;
                        controlled.push([nr, nc]);
                        if (board[nr][nc]) break;
                    }
                }
            }
            
            return controlled;
        }

        function updateBoard() {
            const allControlled = {};
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col]) {
                        const controlled = getControlledSquares(row, col, board[row][col]);
                        for (let i = 0; i < controlled.length; i++) {
                            const r = controlled[i][0];
                            const c = controlled[i][1];
                            allControlled[r + ',' + c] = true;
                        }
                    }
                }
            }
            
            const squares = document.querySelectorAll('.square');
            squares.forEach(function(square) {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                
                square.classList.remove('controlled', 'best-placement');
                
                // Afficher les cases contrôlées
                if (showControlled && allControlled[row + ',' + col]) {
                    square.classList.add('controlled');
                }
                
                // Afficher la meilleure position
                if (bestPosition && row === bestPosition[0] && col === bestPosition[1]) {
                    square.classList.add('best-placement');
                }
                
                square.textContent = board[row][col] ? board[row][col].symbol : '';
            });
        }

        function updateScore() {
            score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col]) {
                        score++;
                    }
                }
            }
            document.getElementById('scoreDisplay').textContent = `Score: ${score} pièces placées`;
        }

        function updateBestPosition() {
            if (!selectedPiece) {
                bestPosition = null;
                hideBestMove();
                updateBoard();
                return;
            }
            
            // Calculer la meilleure position pour la pièce sélectionnée
            bestPosition = findBestPlacement(selectedPiece);
            
            // Mettre à jour l'affichage
            updateBoard();
            
            // Afficher ou masquer le message de meilleur coup
            if (bestPosition) {
                const [row, col] = bestPosition;
                const colName = String.fromCharCode(97 + col);
                const rowName = 8 - row;
                showBestMove(`Meilleure case pour ${selectedPiece.symbol}: ${colName}${rowName}`);
            } else {
                hideBestMove();
            }
        }

        function findBestPlacement(piece) {
            let bestPosition = null;
            let bestScore = -1;
            
            // Évaluer chaque position possible
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidPlacement(row, col, piece)) {
                        // Simuler le placement
                        board[row][col] = {
                            symbol: piece.symbol,
                            type: piece.type,
                            color: piece.color
                        };
                        
                        // Évaluer ce placement
                        const placementScore = evaluatePlacement();
                        
                        // Annuler le placement simulé
                        board[row][col] = null;
                        
                        // Mettre à jour le meilleur placement
                        if (placementScore > bestScore) {
                            bestScore = placementScore;
                            bestPosition = [row, col];
                        }
                    }
                }
            }
            
            return bestPosition;
        }

        function evaluatePlacement() {
            // Cette fonction évalue la qualité d'un placement en comptant le nombre
            // de cases qui restent disponibles pour d'autres pièces
            
            let availableSquares = 0;
            
            // Pour chaque type de pièce, compter les placements possibles
            const pieceTypes = ['king', 'queen', 'rook', 'bishop', 'knight', 'pawn'];
            
            for (let type of pieceTypes) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (!board[row][col] && isValidPlacement(row, col, {type: type, color: 'white'})) {
                            availableSquares++;
                        }
                    }
                }
            }
            
            return availableSquares;
        }

        function showBestMove(message) {
            const bestMoveEl = document.getElementById('bestMove');
            bestMoveEl.textContent = message;
            bestMoveEl.classList.remove('hidden');
        }

        function hideBestMove() {
            const bestMoveEl = document.getElementById('bestMove');
            bestMoveEl.classList.add('hidden');
        }

        function toggleControlled() {
            showControlled = !showControlled;
            updateBoard();
        }

        function clearBoard() {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    board[i][j] = null;
                }
            }
            updateBoard();
            updateScore();
            hideBestMove();
            bestPosition = null;
        }

        // Initialiser l'échiquier au chargement
        initBoard();
    </script>
</body>
</html>